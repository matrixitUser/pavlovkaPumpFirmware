#include "main.h"


#ifndef __FRAMEMMODBUS_H__
	#define __FRAMEMMODBUS_H__

	#if !defined(__CONFIG_H__)
//*		#error   //попытка убрать функции регистратора
	#endif

	typedef enum
	{
		//0x0000~0x00FF => Config

		REGHLD_PASSWORD_SESSION_0 = 0x0400,
		REGHLD_PASSWORD_SESSION_24 = 0x0418,

		//HOLDING registers 16-bit	0x1000~0x1FFF

		//HOLDING registers 32-bit	0x2000~0x2FFF
		REGHLD_TIMESTAMP = 0x2000,
		REGHLD_COUNTER_PULSE_1 = 0x2004,
		REGHLD_COUNTER_PULSE_2 = 0x2008,
		REGHLD_COUNTER_PULSE_3 = 0x200C,
		REGHLD_COUNTER_PULSE_4 = 0x2010,
		REGHLD_COUNTER_PULSE_5 = 0x2014,
		REGHLD_COUNTER_PULSE_6 = 0x2018,
		REGHLD_COUNTER_PULSE_7 = 0x201C,
		REGHLD_COUNTER_PULSE_8 = 0x2020,
		REGHLD_COUNTER_PULSE_9 = 0x2024,
		REGHLD_COUNTER_PULSE_10 = 0x2028,
		REGHLD_COUNTER_PULSE_11 = 0x202C,
		REGHLD_COUNTER_PULSE_12 = 0x2030,
		REGHLD_COUNTER_PULSE_13 = 0x2034,
		REGHLD_COUNTER_PULSE_14 = 0x2038,
		REGHLD_COUNTER_PULSE_15 = 0x203C,
		REGHLD_COUNTER_PULSE_16 = 0x2040,

		////
		REGHLD_TIMESTAMP_COPY = 0x2200,

		REGHLD_COUNTER_VALUE_1 = 0x2204,
		REGHLD_COUNTER_PARAM_1 = 0x2208,
		REGHLD_COUNTER_POINT_1 = 0x220A,
		REGHLD_COUNTER_UNIT_1 = 0x220B,

		REGHLD_COUNTER_VALUE_2 = 0x220C,
		REGHLD_COUNTER_PARAM_2 = 0x2210,
		REGHLD_COUNTER_POINT_2 = 0x2212,
		REGHLD_COUNTER_UNIT_2 = 0x2213,

		REGHLD_COUNTER_VALUE_3 = 0x2214,
		REGHLD_COUNTER_PARAM_3 = 0x2218,
		REGHLD_COUNTER_POINT_3 = 0x221A,
		REGHLD_COUNTER_UNIT_3 = 0x221B,

		REGHLD_COUNTER_VALUE_4 = 0x221C,
		REGHLD_COUNTER_PARAM_4 = 0x2220,
		REGHLD_COUNTER_POINT_4 = 0x2222,
		REGHLD_COUNTER_UNIT_4 = 0x2223,

		REGHLD_COUNTER_VALUE_5 = 0x2224,
		REGHLD_COUNTER_PARAM_5 = 0x2228,
		REGHLD_COUNTER_POINT_5 = 0x222A,
		REGHLD_COUNTER_UNIT_5 = 0x222B,

		REGHLD_COUNTER_VALUE_6 = 0x222C,
		REGHLD_COUNTER_PARAM_6 = 0x2230,
		REGHLD_COUNTER_POINT_6 = 0x2232,
		REGHLD_COUNTER_UNIT_6 = 0x2233,

		REGHLD_COUNTER_VALUE_7 = 0x2234,
		REGHLD_COUNTER_PARAM_7 = 0x2238,
		REGHLD_COUNTER_POINT_7 = 0x223A,
		REGHLD_COUNTER_UNIT_7 = 0x223B,

		REGHLD_COUNTER_VALUE_8 = 0x223C,
		REGHLD_COUNTER_PARAM_8 = 0x2240,
		REGHLD_COUNTER_POINT_8 = 0x2242,
		REGHLD_COUNTER_UNIT_8 = 0x2243,

		REGHLD_COUNTER_VALUE_9 = 0x2244,
		REGHLD_COUNTER_PARAM_9 = 0x2248,
		REGHLD_COUNTER_POINT_9 = 0x224A,
		REGHLD_COUNTER_UNIT_9 = 0x224B,

		REGHLD_COUNTER_VALUE_10 = 0x224C,
		REGHLD_COUNTER_PARAM_10 = 0x2250,
		REGHLD_COUNTER_POINT_10 = 0x2252,
		REGHLD_COUNTER_UNIT_10 = 0x2253,

		REGHLD_COUNTER_VALUE_11 = 0x2254,
		REGHLD_COUNTER_PARAM_11 = 0x2258,
		REGHLD_COUNTER_POINT_11 = 0x225A,
		REGHLD_COUNTER_UNIT_11 = 0x225B,

		REGHLD_COUNTER_VALUE_12 = 0x225C,
		REGHLD_COUNTER_PARAM_12 = 0x2260,
		REGHLD_COUNTER_POINT_12 = 0x2262,
		REGHLD_COUNTER_UNIT_12 = 0x2263,

		REGHLD_COUNTER_VALUE_13 = 0x2264,
		REGHLD_COUNTER_PARAM_13 = 0x2268,
		REGHLD_COUNTER_POINT_13 = 0x226A,
		REGHLD_COUNTER_UNIT_13 = 0x226B,

		REGHLD_COUNTER_VALUE_14 = 0x226C,
		REGHLD_COUNTER_PARAM_14 = 0x2270,
		REGHLD_COUNTER_POINT_14 = 0x2272,
		REGHLD_COUNTER_UNIT_14 = 0x2273,

		REGHLD_COUNTER_VALUE_15 = 0x2274,
		REGHLD_COUNTER_PARAM_15 = 0x2278,
		REGHLD_COUNTER_POINT_15 = 0x227A,
		REGHLD_COUNTER_UNIT_15 = 0x227B,

		REGHLD_COUNTER_VALUE_16 = 0x227C,
		REGHLD_COUNTER_PARAM_16 = 0x2280,
		REGHLD_COUNTER_POINT_16 = 0x2282,
		REGHLD_COUNTER_UNIT_16 = 0x2283,
		//0x2264

		REGHLD_BOOTLOADER_KEY = 0x3FFC,

		//HOLDING registers other	0x3000~0x3FFF

		//INPUT registers 8-bit		0x4000~0x4FFF
		REGINP_CHANNELS	= 0x4000,
		REGINP_COUNTERS	= 0x4001,
		REGINP_DIGITAL = 0x4002,

		//INPUT registers 16-bit	0x5000~0x5FFF
		REGINP_PINSTATE = 0x5000,
		REGINP_PINSTATE_2 = 0x5002,
		REGINP_ADC_TEMP = 0x5004,
		REGINP_ADC_BAT = 0x5006,
		REGINP_ADC_VBAT = 0x5008,
		REGINP_ADC_MAINS = 0x500A,
		REGINP_RTCCHECK_0 = 0x5010,
		REGINP_RTCCHECK_1 = 0x5014,
		REGINP_RTCCHECK_2 = 0x5018,
		REGINP_UNIT_TOTAL = 0x501E,
		REGINP_UNIT_MAXLEN = 0x501F,
		REGINP_UNIT_0 = 0x5020,
		REGINP_UNIT_END = 0x507F,	//TOTAL*MAXLEN = 0x60 (96)

		//INPUT registers 32-bit	0x6000~0x6FFF
		REGINP_CHIPID_1	= 0x6000,
		REGINP_CHIPID_2	= 0x6004,
		REGINP_CHIPID_3	= 0x6008
	}
	ModbusRegister_e;

	//INPUT registers other		0x7000~0x7FFF

	////////////////////////////////////

	#define FUNCTION_ALARM          	99
	///
	#define MODBUS_FUNCTION_READ_HOLDING_REGISTERS		3
	#define MODBUS_FUNCTION_READ_INPUT_REGISTERS		4
	#define MODBUS_FUNCTION_WRITE_HOLDING_REGISTERS		16

	//50-65 Pavlovka
	#define MODBUS_USER_FUNCTION_GET_EQUIPMENT_INFO			50
	#define MODBUS_USER_FUNCTION_MODE_CHOICE				51
	#define MODBUS_USER_FUNCTION_TRANSFER_TO_USART1			52
	#define MODBUS_USER_FUNCTION_UPP_CONTACTOR_ACTIVATE		54
	#define MODBUS_DEBUG_FUNCTION							55
	#define MODBUS_DEBUG_TERMINAL							56
	#define MODBUS_DEBUG_PRINFF								57
	#define MODBUS_SWITCH_CONTROLLER_MODE					58


	//65-72
	#define MODBUS_USER_FUNCTION_READ_ARCHIVE			65
	#define MODBUS_USER_FUNCTION_SET_CHANNELS			69
	#define MODBUS_USER_FUNCTION_RESET					70
	#define MODBUS_USER_FUNCTION_SET_RELEASE			71
	#define MODBUS_USER_FUNCTION_BOOTLOADER_START		72
	#define MODBUS_USER_FUNCTION_SET_LIGTH				73
	#define MODBUS_USER_FUNCTION_ASTR_TIMER				74
	#define MODBUS_USER_FUNCTION_GET_ABNORMAL			75        //Код Ильнура
	#define MODBUS_USER_FUNCTION_GET_ARCHIVE			76  //0x4C
	#ifdef PAVLOVKA
		#define MODBUS_USER_FUNCTION_ACK					78  //0x4E
	#else
		#define MODBUS_USER_FUNCTION_ACK					77  //0x4D
	#endif
	#define MODBUS_USER_FUNCTION_WRITE_BKP				80
	//#define MODBUS_USER_FUNCTION_FLASHCONFIG			96//0-read 1-write 2-default 11-write w/ chipid check
	#define MODBUS_USER_FUNCTION_CONFIG_SEND    		96   //отправка конфига   // 0x60
	#define MODBUS_USER_FUNCTION_CONFIG_RECEIVE    		97   //получение конфига //  0x61


	//100-110
	#define MODBUS_USER_FUNCTION_BOOTLOADER_BKPSIZE			102
	#define MODBUS_USER_FUNCTION_BOOTLOADER_BKPREAD			103
	#define MODBUS_USER_FUNCTION_BOOTLOADER_BKPERASE		104
	#define MODBUS_USER_FUNCTION_BOOTLOADER_BKPWRITE		105
	#define MODBUS_USER_FUNCTION_BOOTLOADER_PSIZE			106
	#define MODBUS_USER_FUNCTION_BOOTLOADER_PREAD			107
	#define MODBUS_USER_FUNCTION_BOOTLOADER_PERASE			108
	#define MODBUS_USER_FUNCTION_BOOTLOADER_PWRITE			109
	#define MODBUS_USER_FUNCTION_BOOTLOADER_PSTART			110

	///
	#define MODBUS_ERROR_NO_ERROR					0
	#define MODBUS_ERROR_FUNCTION_CODE_INVALID 		1
	#define MODBUS_ERROR_ADDRESS_NOT_EXIST			2
	#define MODBUS_ERROR_INVALID_VALUE				3
	#define MODBUS_ERROR_EXCEPTION					4
	#define MODBUS_ERROR_STARTING_PROCESS			5
	#define MODBUS_ERROR_IN_PROCESS					6
	#define MODBUS_ERROR_FUNCTION_CANT_EXECUTE		7
	#define MODBUS_ERROR_EXMEM_PARITY_ERROR			8
	#define MODBUS_ERROR_MEMORY_ALIGN_ERROR			9

	#define MODBUS_ERROR_INSUFFICIENT_MEMORY		32
	#define MODBUS_ERROR_ARCHIVE_NOT_EXIST			33
	#define MODBUS_ERROR_ARCHIVE_OUT_OF_RANGE		34
	#define MODBUS_ERROR_ARCHIVE_NULL_RECORD		35

	#define MODBUS_ERROR_NO_ACCESS					60

	#define MODBUS_ERROR_NOT_IMPLEMENTED			180

	// MODBUS REGR - регистры для ЧТЕНИЯ
	// вспомогательное
	#define MODBUS_REG_TYPE_OFFSET					(4)
	#define MODBUS_REG_MB_OFFSET					(3)
	#define MODBUS_REG_SIZE_OFFSET					(0)
	//#define MODBUS_REGR_IS_COMPUTE				(0x10)	//регистр вычисляется при обработке запроса
	#define MODBUS_REG_IS_MB						(0x08)	//регистр выдаётся в формате модбас (MSB first)
	#define MODBUS_REG_SIZE_MASK					(0x07)	//выравнивание - 1/2/4 байта

	#define MODBUS_REGR_TYPE_CONSTANT				(0)
	#define MODBUS_REGR_TYPE_COMPUTE				(1)
	#define MODBUS_REGR_TYPE_LINK					(2)

	//типы регистров для запроса
	#define MODBUS_REGR_TYPE_CONSTANT_BYTE			((MODBUS_REGR_TYPE_CONSTANT << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (1 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_CONSTANT_UINT16		((MODBUS_REGR_TYPE_CONSTANT << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_CONSTANT_UINT32		((MODBUS_REGR_TYPE_CONSTANT << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_CONSTANT_MB_UINT16		((MODBUS_REGR_TYPE_CONSTANT << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_CONSTANT_MB_UINT32		((MODBUS_REGR_TYPE_CONSTANT << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_LINK_BYTE				((MODBUS_REGR_TYPE_LINK << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (1 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_LINK_UINT16			((MODBUS_REGR_TYPE_LINK << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_LINK_UINT32			((MODBUS_REGR_TYPE_LINK << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_LINK_MB_UINT16			((MODBUS_REGR_TYPE_LINK << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_LINK_MB_UINT32			((MODBUS_REGR_TYPE_LINK << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_COMPUTE_BYTE			((MODBUS_REGR_TYPE_COMPUTE << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (1 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_COMPUTE_UINT16			((MODBUS_REGR_TYPE_COMPUTE << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_COMPUTE_UINT32			((MODBUS_REGR_TYPE_COMPUTE << MODBUS_REG_TYPE_OFFSET) | (0 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_COMPUTE_MB_UINT16		((MODBUS_REGR_TYPE_COMPUTE << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGR_TYPE_COMPUTE_MB_UINT32		((MODBUS_REGR_TYPE_COMPUTE << MODBUS_REG_TYPE_OFFSET) | (1 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	// вычислимые регистры
	#define MODBUS_REGR_COMPUTE_NO_COMPUTE			((void *) 0x00000000UL)
	#define MODBUS_REGR_COMPUTE_TIMESTAMP			((void *) 0x00000001UL)
	#define MODBUS_REGR_COMPUTE_RTC_CHIPID_0		((void *) 0x00000008UL)
	#define MODBUS_REGR_COMPUTE_RTC_CHIPID_1		((void *) 0x00000009UL)
	#define MODBUS_REGR_COMPUTE_RTC_CHIPID_2		((void *) 0x0000000AUL)
	#define MODBUS_REGR_COMPUTE_RTC_CHECK_0			((void *) 0x0000000CUL)
	#define MODBUS_REGR_COMPUTE_RTC_CHECK_1			((void *) 0x0000000DUL)
	#define MODBUS_REGR_COMPUTE_RTC_CHECK_2			((void *) 0x0000000EUL)
	#define MODBUS_REGR_COMPUTE_COUNTER_PULSE_0		((void *) 0x00000010UL)
	//...
	#define MODBUS_REGR_COMPUTE_COUNTER_PULSE_15	((void *) 0x0000001FUL)
	#define MODBUS_REGR_COMPUTE_PINSTATE_0			((void *) 0x00000020UL)
	#define MODBUS_REGR_COMPUTE_PINSTATE_1			((void *) 0x00000021UL)
	#define MODBUS_REGR_COMPUTE_ADC_TEMP			((void *) 0x00000022UL)
	#define MODBUS_REGR_COMPUTE_ADC_BAT				((void *) 0x00000023UL)
	#define MODBUS_REGR_COMPUTE_COUNTER_VALUE_0		((void *) 0x00000030UL)
	//...
	#define MODBUS_REGR_COMPUTE_COUNTER_VALUE_15	((void *) 0x0000003FUL)
	#define MODBUS_REGR_COMPUTE_CFGMODE				((void *) 0x00000040UL)

	////
	// MODBUS REGW - регистры для ЗАПИСИ
	#define MODBUS_REGW_TYPE_BYTE					((0 << MODBUS_REG_MB_OFFSET) | (1 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGW_TYPE_UINT16					((0 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGW_TYPE_UINT32					((0 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGW_TYPE_MB_UINT16				((1 << MODBUS_REG_MB_OFFSET) | (2 << MODBUS_REG_SIZE_OFFSET))
	#define MODBUS_REGW_TYPE_MB_UINT32				((1 << MODBUS_REG_MB_OFFSET) | (4 << MODBUS_REG_SIZE_OFFSET))

	#define MODBUS_REGW_COMMIT_CONFIG				(0x00000001)
	#define MODBUS_REGW_COMMIT_PASSWORD				(0x00000002)
	#define MODBUS_REGW_COMMIT_TIMESTAMP			(0x00000004)
	#define MODBUS_REGW_COMMIT_BOOTLOADER_KEY		(0x00008000)

	//

	#define ARCHIVE_TYPE_HOUR						0
	#define ARCHIVE_TYPE_AE							9

	PUBLIC void FrameModbus_Init(void);
	PUBLIC void FrameModbus_DataProcess(u8 *data, u16 len);
	PUBLIC void FrameModbus_Send(u8 fun, u8* data, u8 len);
	PUBLIC void CMD50(uint8_t *ret);
	void ServerCallbackParse(u8 hdl, u32 param);

#endif
